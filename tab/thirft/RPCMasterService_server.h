// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "RPCMasterService.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TBufferTransports.h>
//Yujie Edit
#include "winsock2i.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::UpdateService;

class RPCMasterServiceHandler : virtual public RPCMasterServiceIf {
 public:
  RPCMasterServiceHandler() {
    // Your initialization goes here
  }

  bool updateProgram(const VersionInfo& _versionInfo) {
    // Your implementation goes here
    printf("updateProgram\n");
  }

  bool getupdateInfo(const VersionInfo& _versionInfo) {
    // Your implementation goes here
    printf("getupdateInfo\n");
  }

  bool getUpdateFile(const std::vector<FileData> & _listFileData) {
    // Your implementation goes here
    printf("getUpdateFile\n");
  }

};



//int main(int argc, char **argv) {
//      int port = 27020;

//      boost::shared_ptr<ConcreteCollectLoadHandler> handler(new ConcreteCollectLoadHandler());
//      boost::shared_ptr<TProcessor> processor(new ReportNodeLoadInfoProcessor(handler));
//      boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(m_nOpenPort));
//      boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
//      boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
//      //支持管理100个节点
//      int nConCurrecncy = 100;//boost::thread::hardware_concurrency();
//      boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(nConCurrecncy);
//      threadManager->threadFactory(boost::make_shared<PlatformThreadFactory>());
//      threadManager->start();
//      s_pPoolServer = boost::make_shared<TThreadPoolServer>(processor, serverTransport, transportFactory, protocolFactory, threadManager);
//      if (s_pPoolServer)
//      {
//          s_pPoolServer->serve();
//      }

////  shared_ptr<RPCMasterServiceHandler> handler(new RPCMasterServiceHandler());
////  shared_ptr<TProcessor> processor(new RPCMasterServiceProcessor(handler));
////  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
////  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
////  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

////  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
////  server.serve();

//  return 0;
//}

